/*
 * Copyright (c) 2021-2022 Siengine Technology, Inc.
 *
 * Sienginie Camera Interface driver
 *
 * Author: Siengine Technology, Inc.
 */

#include "ov2311.h"

#define ADDR_MAX9295	0x62
#define ADDR_OV2311_SENSOR	0x60

struct reg_value8 ov2311_1600x1300_yuv_60fps[] = {
	{ 0x0103, 0x01, 0 },
	{ 0x0100, 0x00, 0 },
	{ 0x010c, 0x02, 0 },
	{ 0x010b, 0x01, 0 },
	{ 0x0300, 0x01, 0 },
	{ 0x0302, 0x32, 0 },
	{ 0x0303, 0x00, 0 },
	{ 0x0304, 0x03, 0 },
	{ 0x0305, 0x02, 0 },
	{ 0x0306, 0x01, 0 },
	{ 0x030d, 0x5a, 0 },
	{ 0x030e, 0x04, 0 },
	{ 0x3001, 0x02, 0 },
	{ 0x3004, 0x00, 0 },
	{ 0x3005, 0x00, 0 },
	{ 0x3006, 0x0a, 0 },
	{ 0x3011, 0x0d, 0 },
	{ 0x3014, 0x04, 0 },
	{ 0x301c, 0xf0, 0 },
	{ 0x3020, 0x20, 0 },
	{ 0x302c, 0x00, 0 },
	{ 0x302d, 0x00, 0 },
	{ 0x302e, 0x00, 0 },
	{ 0x302f, 0x03, 0 },
	{ 0x3030, 0x10, 0 },
	{ 0x303f, 0x03, 0 },
	{ 0x3103, 0x00, 0 },
	{ 0x3106, 0x08, 0 },
	{ 0x31ff, 0x01, 0 },
	{ 0x3501, 0x05, 0 },
	{ 0x3502, 0x7c, 0 },
	{ 0x3506, 0x00, 0 },
	{ 0x3507, 0x00, 0 },
	{ 0x3620, 0x67, 0 },
	{ 0x3633, 0x78, 0 },
	{ 0x3662, 0x65, 0 },
	{ 0x3664, 0xb0, 0 },
	{ 0x3666, 0x70, 0 },
	{ 0x3670, 0x68, 0 },
	{ 0x3674, 0x10, 0 },
	{ 0x3675, 0x00, 0 },
	{ 0x367e, 0x90, 0 },
	{ 0x3680, 0x84, 0 },
	{ 0x36a2, 0x04, 0 },
	{ 0x36a3, 0x80, 0 },
	{ 0x36b0, 0x00, 0 },
	{ 0x3700, 0x35, 0 },
	{ 0x3704, 0x39, 0 },
	{ 0x370a, 0x50, 0 },
	{ 0x3712, 0x80, 0 }, //0x00
	{ 0x3713, 0x02, 0 },
	{ 0x3778, 0x00, 0 },
	{ 0x379b, 0x01, 0 },
	{ 0x379c, 0x10, 0 },
	{ 0x3800, 0x00, 0 },
	{ 0x3801, 0x00, 0 },
	{ 0x3802, 0x00, 0 },
	{ 0x3803, 0x00, 0 },
	{ 0x3804, 0x06, 0 },
	{ 0x3805, 0x4f, 0 },
	{ 0x3806, 0x05, 0 },
	{ 0x3807, 0x23, 0 },
	{ 0x3808, 0x06, 0 },
	{ 0x3809, 0x40, 0 },
	{ 0x380a, 0x05, 0 },
	{ 0x380b, 0x14, 0 },
	{ 0x380c, 0x03, 0 },
	{ 0x380d, 0xCC, 0 },
	{ 0x380e, 0x05, 0 },
	{ 0x380f, 0x46, 0 },
	{ 0x3810, 0x00, 0 },
	{ 0x3811, 0x08, 0 },
	{ 0x3812, 0x00, 0 },
	{ 0x3813, 0x08, 0 },
	{ 0x3814, 0x11, 0 },
	{ 0x3815, 0x11, 0 },
	{ 0x3816, 0x00, 0 },
	{ 0x3817, 0x01, 0 },
	{ 0x3818, 0x00, 0 },
	{ 0x3819, 0x05, 0 },
	{ 0x3820, 0x00, 0 },
	{ 0x3821, 0x00, 0 },
	{ 0x382b, 0x5a, 0 },
	{ 0x382c, 0x0a, 0 },
	{ 0x382d, 0xf8, 0 },
	{ 0x3881, 0x44, 0 },
	{ 0x3882, 0x02, 0 },
	{ 0x3883, 0x8c, 0 },
	{ 0x3885, 0x07, 0 },
	{ 0x389d, 0x03, 0 },
	{ 0x38a6, 0x00, 0 },
	{ 0x38a7, 0x01, 0 },
	{ 0x38b3, 0x07, 0 },
	{ 0x38b1, 0x00, 0 },
	{ 0x38e5, 0x02, 0 },
	{ 0x38e7, 0x00, 0 },
	{ 0x38e8, 0x00, 0 },
	{ 0x3910, 0xff, 0 },
	{ 0x3911, 0xff, 0 },
	{ 0x3912, 0x08, 0 },
	{ 0x3913, 0x00, 0 },
	{ 0x3914, 0x00, 0 },
	{ 0x3915, 0x00, 0 },
	{ 0x391c, 0x00, 0 },
	{ 0x3920, 0xff, 0 },
	{ 0x3921, 0x80, 0 },
	{ 0x3922, 0x00, 0 },
	{ 0x3923, 0x00, 0 },
	{ 0x3924, 0x05, 0 },
	{ 0x3925, 0x00, 0 },
	{ 0x3926, 0x00, 0 },
	{ 0x3927, 0x00, 0 },
	{ 0x3928, 0x1a, 0 },
	{ 0x392d, 0x03, 0 },
	{ 0x392e, 0xa8, 0 },
	{ 0x392f, 0x08, 0 },
	{ 0x4001, 0x00, 0 },
	{ 0x4003, 0x40, 0 },
	{ 0x4008, 0x04, 0 },
	{ 0x4009, 0x1b, 0 },
	{ 0x400c, 0x04, 0 },
	{ 0x400d, 0x1b, 0 },
	{ 0x4010, 0xf4, 0 },
	{ 0x4011, 0x00, 0 },
	{ 0x4016, 0x00, 0 },
	{ 0x4017, 0x04, 0 },
	{ 0x4042, 0x11, 0 },
	{ 0x4043, 0x70, 0 },
	{ 0x4045, 0x00, 0 },
	{ 0x4409, 0x5f, 0 },
	{ 0x4509, 0x00, 0 },
	{ 0x450b, 0x00, 0 },
	{ 0x4600, 0x00, 0 },
	{ 0x4601, 0xa0, 0 },
	{ 0x4708, 0x09, 0 },
	{ 0x470c, 0x81, 0 },
	{ 0x4710, 0x06, 0 },
	{ 0x4711, 0x00, 0 },
	{ 0x4800, 0x00, 0 },
	{ 0x481f, 0x30, 0 },
	{ 0x4837, 0x14, 0 },
	{ 0x4f00, 0x00, 0 },
	{ 0x4f07, 0x00, 0 },
	{ 0x4f08, 0x03, 0 },
	{ 0x4f09, 0x08, 0 },
	{ 0x4f0c, 0x05, 0 },
	{ 0x4f0d, 0xb4, 0 },
	{ 0x4f10, 0x00, 0 },
	{ 0x4f11, 0x00, 0 },
	{ 0x4f12, 0x07, 0 },
	{ 0x4f13, 0xe2, 0 },
	{ 0x5000, 0x9f, 0 },
	{ 0x5001, 0x20, 0 },
	{ 0x5026, 0x00, 0 },
	{ 0x5c00, 0x00, 0 },
	{ 0x5c01, 0x2c, 0 },
	{ 0x5c02, 0x00, 0 },
	{ 0x5c03, 0x7f, 0 },
	{ 0x5e00, 0x00, 0 },
	{ 0x5e01, 0x41, 0 },
	{ 0x38b1, 0x02, 0 },

	{ 0x0100, 0x01, 0 },

	{ 0x4500, 0x74, 0 },
	{ 0x3006, 0x08, 0 }, //strobe pin output enable
	{ 0x3004, 0x02, 0 },
	{ 0x3007, 0x02, 0 },
	{ 0x301c, 0x20, 0 }, //enable the clock for group write
	{ 0x3020, 0x20, 0 }, //strobe logic always on
	{ 0x3025, 0x02, 0 },
	{ 0x3920, 0xff, 0 },
	{ 0x3924, 0x00, 0 },
	{ 0x392c, 0x00, 0 },
	{ 0x392d, 0x03, 0 },
	{ 0x392e, 0x88, 0 },
	{ 0x392f, 0xcb, 0 },

	{ 0x3028, 0x00, 0 },
	{ 0x3501, 0x00, 0 }, //exp
	{ 0x3502, 0x4e, 0 },
	{ 0x3508, 0x04, 0 }, //gain
	{ 0x3509, 0xe2, 0 },
	{ 0x3927, 0x00, 0 }, //strobe width
	{ 0x3928, 0x4e, 0 },
	{ 0x3929, 0x04, 0 }, //strobe start pin, vts - Texposure - 7 - Tnegative
	{ 0x392a, 0xf1, 0 },
	{ 0x3208, 0x10, 0 },
	{ 0x3208, 0xa0, 0 },
	{ 0x0100, 0x00, 0 },
	{ 0x3712, 0x00, 0 },
	{ 0x0100, 0x01, 0 },
	{ TABLE_END, 0x00, 0 },
};

struct reg_value8 max9295a_ov2311_config[] = {
//	{ 0x0010, 0x21, 100}, //Apply Reset Oneshot for changes
	{ 0x02be, 0x90, 0 },//Enable sensor power down pin. Put imager in ,Active mode
	{ 0x02d4, 0x60, 0 },//Enable sensor reset pin
	{ 0x03f1, 0x89, 0 },//Output RCLK to sensor.
	{ 0x02d3, 0x90, 0 },
	{ 0x0331, 0x11, 0 },// Set 4 lanes for serializer (ctrl1_num_lanes = 3)
	{ 0x0318, 0x5E, 0 },//yuv422 input only
	{ TABLE_END, 0x00, 0 },
};

static void sensor_delay(uint32_t msec)
{
	if (msec <= 20)
		usleep_range(msec * 1000, msec * 1000);
	else
		msleep(msec);
}

int ov2311_write_reg(struct i2c_client *i2c_client, unsigned short reg, unsigned char val)
{
	return sensor_write_reg8(i2c_client, ADDR_OV2311_SENSOR, reg, val);
}

int ov2311_initialize(struct i2c_client *i2c_client, struct reg_value8 *config_data)
{
	int i = 0;
	int retval = 0;

	while (1) {
		if (config_data[i].reg_addr == TABLE_END)
			break;

		retval = ov2311_write_reg(i2c_client, config_data[i].reg_addr, config_data[i].val);
		if (retval < 0) {
			break;
		}
		if (config_data[i].delay_ms != 0) {
			sensor_delay(config_data[i].delay_ms);
		}
		i++;
	}

	return retval;
}
